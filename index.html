<!DOCTYPE html>
<html lang="pl" manifest="Cache.manifest">
<head>
    <meta charset="UTF-8">
    <title>Karo Host Auto Exploit Compressed + New Webkit Version 9.00 fw</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            font-family: 'Courier New', monospace;
            font-size: 20px;
            font-weight: lighter;
            text-align: center;
            color: #00ff00;
            background: linear-gradient(135deg, #0A0A0A 0%, #1A1920 100%);
            background-size: cover;
            overflow: hidden;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .container {
            width: 90%;
            max-width: 900px;
            padding: 30px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ff00;
            border-radius: 20px;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.5), inset 0 0 8px rgba(0, 255, 0, 0.3);
            backdrop-filter: blur(8px);
        }
        h1 {
            font-size: 40px;
            color: #00ff00;
            text-shadow: 0 0 10px #00ff00, 0 0 20px #00ff00;
            margin: 10px 0;
            letter-spacing: 2px;
        }
        #progress {
            font-size: 28px;
            font-weight: bold;
            color: #ffffff;
            text-shadow: 0 0 10px #ffffff, 0 0 20px #ffffff;
            margin: 20px 0;
            letter-spacing: 1px;
        }
        .error {
            color: #ff0000;
            text-shadow: 0 0 10px #ff0000, 0 0 20px #ff0000;
        }
        button {
            background: rgba(0, 0, 0, 0.7);
            color: #00ff00;
            border: 2px solid #00ff00;
            border-radius: 12px;
            padding: 15px 40px;
            font-size: 22px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
            margin: 10px;
            transition: background 0.3s, color 0.3s, box-shadow 0.3s, transform 0.3s;
        }
        button:hover {
            background: #00ff00;
            color: #000000;
            box-shadow: 0 0 20px #00ff00;
            transform: scale(1.05);
        }
        .progress-bar {
            width: 60%;
            height: 25px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #00ff00;
            border-radius: 12px;
            margin: 20px auto;
            overflow: hidden;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }
        .progress {
            width: 0;
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #00cc00);
            box-shadow: 0 0 10px #00ff00;
            transition: width 1s ease-in-out;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1;
            padding-top: 100px;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(5px);
        }
        .modal-content {
            font-family: 'Courier New', monospace;
            font-size: 20px;
            background: rgba(0, 0, 0, 0.85);
            color: #00ff00;
            margin: auto;
            padding: 20px;
            border: 2px solid #00ff00;
            border-radius: 15px;
            width: 70%;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
        }
        #psip {
            text-align: center;
            margin: 20px auto;
            width: 25%;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 1.5em;
            border: none;
            padding: 1em;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 20px;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
            backdrop-filter: blur(8px);
            transition: box-shadow 0.3s, transform 0.3s;
        }
        #psip:hover {
            box-shadow: 0 0 20px #00ff00;
            transform: scale(1.05);
        }
        a, .TextCaption {
            color: #00ff00;
            text-decoration: none;
            text-shadow: 0 0 5px #00ff00;
            transition: text-shadow 0.3s, transform 0.3s;
        }
        a:hover, .TextCaption:hover {
            text-shadow: 0 0 10px #00ff00;
            transform: scale(1.1);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Karo Host Auto Exploit Compressed + New Webkit Version 9.00 fw</h1>
        <h1 id="progress">Jailbreaking... Wait</h1>
        <div class="progress-bar">
            <div class="progress" id="progressBar"></div>
        </div>
        <div id="all" style="text-align:center; display:none">
            <br><br><br>
        </div>
    </div>

    <script>
        // Sprawdzenie user agenta dla PS4
        function checkPS4() {
            const userAgent = navigator.userAgent.toLowerCase();
            const isPS4 = userAgent.includes('playstation 4') && userAgent.includes('webkit');
            const progressBar = document.getElementById('progressBar');
            if (!isPS4) {
                document.getElementById('progress').textContent = 'Błąd: To nie PS4 albo brak WebKit! Wywalam!';
                document.getElementById('progress').classList.add('error');
                progressBar.style.width = '0%';
                throw new Error('To nie konsola PS4 lub brak WebKit!');
            }
            console.log('Wykryto PS4 WebKit:', userAgent);
            localStorage.setItem('lastUserAgent', userAgent);
            progressBar.style.width = '30%';
        }

        // Twoje oryginalne funkcje (nietknięte)
        if (window.applicationCache.status == '0') {
            window.location.replace("cache.html");
        }

        function loadFile(fileName) {
            let xhr = new XMLHttpRequest();
            xhr.open("GET", fileName, false);
            xhr.overrideMimeType("text/plain; charset=x-user-defined");
            xhr.send();
            let array = Uint8Array.from(xhr.response, c => c.charCodeAt(0));
            if (fileName.endsWith(".bz2")) {
                try {
                    PLS = bzip2.simple(bzip2.array(array));
                } catch (error) {
                    alert(fileName + ": \"" + error + "\"\n");
                    throw error;
                }
            }
            return array;
        }

        function load_pocj() {
            var payload_buffer = chain.syscall(477, 0, 0x300000, 7, 0x1002, -1, 0);
            var buf = new Uint8Array(1);
            var buf_addr = p.leakval(buf);
            var old_buf = p.read8(buf_addr.add32(16));
            var old_sz = p.read4(buf_addr.add32(24));
            p.write8(buf_addr.add32(16), payload_buffer);
            p.write4(buf_addr.add32(24), PLS.length);
            for (var i = 0; i < PLS.length; i++) buf[i] = PLS[i];
            p.write8(buf_addr.add32(16), old_buf);
            p.write4(buf_addr.add32(24), old_sz);
            var pthread = p.malloc(0x10);
            chain.call(libKernelBase.add32(OFFSET_lk_pthread_create), pthread, 0x0, payload_buffer, 0);
            allset();
        }

        function white() {
            document.getElementById("progress").style.color = "white";
        }
        function green() {
            document.getElementById("progress").style.color = "#00ff00";
        }

        function jbdone() {
            document.getElementById("input")?.remove();
            document.getElementById("progress").style.color = "#00ff00";
            window.progress.innerHTML = "Jailbreak Done";
            document.getElementById('progressBar').style.width = '80%';
            setTimeout(goldhen212, 500);
            setTimeout(white, 500);
            setTimeout(green, 800);
            setTimeout(white, 1100);
            setTimeout(green, 1500);
            setTimeout(white, 2000);
            setTimeout(green, 2500);
            setTimeout(white, 3000);
        }

        function allset() {
            window.progress.innerHTML = LoadedMSG;
            document.getElementById('progressBar').style.width = '100%';
        }

        function close_browser() {
            window.close();
        }

        function runScript(what) {
            var xhr = new XMLHttpRequest();
            xhr.open('GET', what, false);
            xhr.send('');
            eval.call(window, xhr.responseText);
        }

        function print() {}

        function load_poc2() {
            var payload_buffer = chain.syscall(477, 0x0, 0x300000, 0x7, 0x1000, 0xFFFFFFFF, 0);
            var payload_loader = p.malloc32(0x1000);
            var BLDR = payload_loader.backing;
            BLDR[0]=0x56415741;BLDR[1]=0x83485541;BLDR[2]=0x894818EC;BLDR[3]=0xC748243C;BLDR[4]=0x10082444;BLDR[5]=0x483C2302;BLDR[6]=0x102444C7;BLDR[7]=0x00000000;BLDR[8]=0x000002BF;BLDR[9]=0x0001BE00;BLDR[10]=0xD2310000;BLDR[11]=0x00009CE8;BLDR[12]=0xC7894100;BLDR[13]=0x8D48C789;BLDR[14]=0xBA082474;BLDR[15]=0x00000010;BLDR[16]=0x000095E8;BLDR[17]=0xFF894400;BLDR[18]=0x000001BE;BLDR[19]=0x0095E800;BLDR[20]=0x89440000;BLDR[21]=0x31F631FF;BLDR[22]=0x0062E8D2;BLDR[23]=0x89410000;BLDR[24]=0x2C8B4CC6;BLDR[25]=0x45C64124;BLDR[26]=0x05EBC300;BLDR[27]=0x01499848;BLDR[28]=0xF78944C5;BLDR[29]=0xBAEE894C;BLDR[30]=0x00001000;BLDR[31]=0x000025E8;BLDR[32]=0x7FC08500;BLDR[33]=0xFF8944E7;BLDR[34]=0x000026E8;BLDR[35]=0xF7894400;BLDR[36]=0x00001EE8;BLDR[37]=0x2414FF00;BLDR[38]=0x18C48348;BLDR[39]=0x5E415D41;BLDR[40]=0x31485F41;BLDR[41]=0xC748C3C0;BLDR[42]=0x000003C0;BLDR[43]=0xCA894900;BLDR[44]=0x48C3050F;BLDR[45]=0x0006C0C7;BLDR[46]=0x89490000;BLDR[47]=0xC3050FCA;BLDR[48]=0x1EC0C748;BLDR[49]=0x49000000;BLDR[50]=0x050FCA89;BLDR[51]=0xC0C748C3;BLDR[52]=0x00000061;BLDR[53]=0x0FCA8949;BLDR[54]=0xC748C305;BLDR[55]=0x000068C0;BLDR[56]=0xCA894900;BLDR[57]=0x48C3050F;BLDR[58]=0x006AC0C7;BLDR[59]=0x89490000;BLDR[60]=0xC3050FCA;
            chain.syscall(74, payload_loader, 0x4000, (0x1 | 0x2 | 0x4));
            var pthread = p.malloc(0x10); {
                chain.fcall(window.syscalls[203], payload_buffer, 0x300000);
                chain.fcall(libKernelBase.add32(OFFSET_lk_pthread_create), pthread, 0x0, payload_loader, payload_buffer);
            }
            chain.run();
            sessionStorage.Paload="yes";
            setTimeout(load_pocl,2000);
        }

        function load_pocl() {
            var payload_buffer = chain.syscall(477, 0, 0x300000, 7, 0x1002, -1, 0);
            var buf = new Uint8Array(1);
            var buf_addr = p.leakval(buf);
            var old_buf = p.read8(buf_addr.add32(16));
            var old_sz = p.read4(buf_addr.add32(24));
            p.write8(buf_addr.add32(16), payload_buffer);
            p.write4(buf_addr.add32(24), PLS.length);
            for (var i = 0; i < PLS.length; i++) buf[i] = PLS[i];
            p.write8(buf_addr.add32(16), old_buf);
            p.write4(buf_addr.add32(24), old_sz);
            var pthread = p.malloc(0x10);
            chain.call(libKernelBase.add32(OFFSET_lk_pthread_create), pthread, 0x0, payload_buffer, 0);
            setTimeout(load_pocB,2000);
        }

        function load_pocB() {
            var req = new XMLHttpRequest();
            req.responseType = "arraybuffer";
            req.open('GET', PLfile);
            req.send();
            req.onreadystatechange = function () {
                if (req.readyState == 4) {
                    PLD = req.response;
                    var payload_buffer = chain.syscall(477, 0, PLD.byteLength*4 , 7, 0x1002, -1, 0);
                    var pl = p.array_from_address(payload_buffer, PLD.byteLength*4);
                    var padding = new Uint8Array(4 - (req.response.byteLength % 4) % 4);
                    var tmp = new Uint8Array(req.response.byteLength + padding.byteLength);
                    tmp.set(new Uint8Array(req.response), 0);
                    tmp.set(padding, req.response.byteLength);
                    var shellcode = new Uint32Array(tmp.buffer);
                    pl.set(shellcode,0);
                    var pthread = p.malloc(0x10);
                    chain.call(libKernelBase.add32(OFFSET_lk_pthread_create), pthread, 0x0, payload_buffer, 0);
                    allset();
                }
            };
        }

        function goldhen212() {
            progress.innerHTML = "Goldhen loading... please wait";
            document.getElementById('progressBar').style.width = '90%';
            LoadedMSG = "GoldHEN Loaded";
            PLfile = "goldhen.bin";
            out_jb = "AllPL";
            load_pocB();
            setTimeout(close_browser, 100);
        }

        function Bloader() {
            progress.innerHTML = "Payload loading... please wait";
            var payload_buffer = chain.syscall(477, 0x0, 0x300000, 0x7, 0x1000, 0xFFFFFFFF, 0);
            var payload_loader = p.malloc32(0x1000);
            var BLDR = payload_loader.backing;
            BLDR[0]=0x56415741;BLDR[1]=0x83485541;BLDR[2]=0x894818EC;BLDR[3]=0xC748243C;BLDR[4]=0x10082444;BLDR[5]=0x483C2302;BLDR[6]=0x102444C7;BLDR[7]=0x00000000;BLDR[8]=0x000002BF;BLDR[9]=0x0001BE00;BLDR[10]=0xD2310000;BLDR[11]=0x00009CE8;BLDR[12]=0xC7894100;BLDR[13]=0x8D48C789;BLDR[14]=0xBA082474;BLDR[15]=0x00000010;BLDR[16]=0x000095E8;BLDR[17]=0xFF894400;BLDR[18]=0x000001BE;BLDR[19]=0x0095E800;BLDR[20]=0x89440000;BLDR[21]=0x31F631FF;BLDR[22]=0x0062E8D2;BLDR[23]=0x89410000;BLDR[24]=0x2C8B4CC6;BLDR[25]=0x45C64124;BLDR[26]=0x05EBC300;BLDR[27]=0x01499848;BLDR[28]=0xF78944C5;BLDR[29]=0xBAEE894C;BLDR[30]=0x00001000;BLDR[31]=0x000025E8;BLDR[32]=0x7FC08500;BLDR[33]=0xFF8944E7;BLDR[34]=0x000026E8;BLDR[35]=0xF7894400;BLDR[36]=0x00001EE8;BLDR[37]=0x2414FF00;BLDR[38]=0x18C48348;BLDR[39]=0x5E415D41;BLDR[40]=0x31485F41;BLDR[41]=0xC748C3C0;BLDR[42]=0x000003C0;BLDR[43]=0xCA894900;BLDR[44]=0x48C3050F;BLDR[45]=0x0006C0C7;BLDR[46]=0x89490000;BLDR[47]=0xC3050FCA;BLDR[48]=0x1EC0C748;BLDR[49]=0x49000000;BLDR[50]=0x050FCA89;BLDR[51]=0xC0C748C3;BLDR[52]=0x00000061;BLDR[53]=0x0FCA8949;BLDR[54]=0xC748C305;BLDR[55]=0x000068C0;BLDR[56]=0xCA894900;BLDR[57]=0x48C3050F;BLDR[58]=0x006AC0C7;BLDR[59]=0x89490000;BLDR[60]=0xC3050FCA;
            chain.syscall(74, payload_loader, 0x4000, (0x1 | 0x2 | 0x4));
            var pthread = p.malloc(0x10); {
                chain.fcall(window.syscalls[203], payload_buffer, 0x300000);
                chain.fcall(libKernelBase.add32(OFFSET_lk_pthread_create), pthread, 0x0, payload_loader, payload_buffer);
            }
            chain.run();
            Binset();
        }

        function allmods() {
            all.style.display = "none";
            gtav.style.display = "block";
        }
        function alldumpers() {
            all.style.display = "none";
            Dumpers.style.display = "block";
        }
        function alltools() {
            all.style.display = "none";
            Tools.style.display = "block";
        }

        // Twoje funkcje bzip2 (nietknięte)
        var bzip2 = {};
        bzip2.array = function(bytes) {
            var bit = 0, byte = 0;
            var BITMASK = [0, 0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F, 0xFF];
            return function(n) {
                var result = 0;
                while (n > 0) {
                    var left = 8 - bit;
                    if (n >= left) {
                        result <<= left;
                        result |= (BITMASK[left] & bytes[byte++]);
                        bit = 0;
                        n -= left;
                    } else {
                        result <<= n;
                        result |= ((bytes[byte] & (BITMASK[n] << (8 - n - bit))) >> (8 - n - bit));
                        bit += n;
                        n = 0;
                    }
                }
                return result;
            };
        };

        bzip2.simple = function(bits) {
            var size = bzip2.header(bits);
            var all = [], chunk = [];
            do {
                all = all.concat(chunk);
                chunk = bzip2.decompress(bits, size);
            } while (chunk != -1);
            return Uint8Array.from(all);
        };

        bzip2.header = function(bits) {
            if (bits(8 * 3) != 4348520) throw "No magic number found.";
            var i = bits(8) - 48;
            if (i < 1 || i > 9) throw "Not a bzip2 archive.";
            return i;
        };

        bzip2.decompress = function(bits, size, len) {
            var MAX_HUFCODE_BITS = 20;
            var MAX_SYMBOLS = 258;
            var SYMBOL_RUNA = 0;
            var SYMBOL_RUNB = 1;
            var GROUP_SIZE = 50;
            var bufsize = 100000 * size;
            for (var h = "", i = 0; i < 6; i++) h += bits(8).toString(16);
            if (h == "177245385090") return -1;
            if (h != "314159265359") throw "Not valid bzip2 data.";
            bits(32);
            if (bits(1)) throw "Unsupported obsolete version.";
            var origPtr = bits(24);
            if (origPtr > bufsize) throw "Initial position larger than buffer size.";
            var t = bits(16);
            var symToByte = new Uint8Array(256), symTotal = 0;
            for (i = 0; i < 16; i++) {
                if (t & (1 << (15 - i))) {
                    var k = bits(16);
                    for (j = 0; j < 16; j++) {
                        if (k & (1 << (15 - j))) {
                            symToByte[symTotal++] = (16 * i) + j;
                        }
                    }
                }
            }
            var groupCount = bits(3);
            if (groupCount < 2 || groupCount > 6) throw "Error 1 while decompressing.";
            var nSelectors = bits(15);
            if (nSelectors == 0) throw "Error 2 while decompressing.";
            var mtfSymbol = [];
            for (var i = 0; i < groupCount; i++) mtfSymbol[i] = i;
            var selectors = new Uint8Array(32768);
            for (var i = 0; i < nSelectors; i++) {
                for (var j = 0; bits(1); j++) if (j >= groupCount) throw "Error 3 while decompressing.";
                var uc = mtfSymbol[j];
                mtfSymbol.splice(j, 1);
                mtfSymbol.splice(0, 0, uc);
                selectors[i] = uc;
            }
            var symCount = symTotal + 2;
            var groups = [];
            for (var j = 0; j < groupCount; j++) {
                var length = new Uint8Array(MAX_SYMBOLS), temp = new Uint8Array(MAX_HUFCODE_BITS + 1);
                t = bits(5);
                for (var i = 0; i < symCount; i++) {
                    while (true) {
                        if (t < 1 || t > MAX_HUFCODE_BITS) throw "Error 4 while decompressing.";
                        if (!bits(1)) break;
                        if (!bits(1)) t++;
                        else t--;
                    }
                    length[i] = t;
                }
                var minLen, maxLen;
                minLen = maxLen = length[0];
                for (var i = 1; i < symCount; i++) {
                    if (length[i] > maxLen) maxLen = length[i];
                    else if (length[i] < minLen) minLen = length[i];
                }
                var hufGroup = groups[j] = {};
                hufGroup.permute = new Uint32Array(MAX_SYMBOLS);
                hufGroup.limit = new Uint32Array(MAX_HUFCODE_BITS + 1);
                hufGroup.base = new Uint32Array(MAX_HUFCODE_BITS + 1);
                hufGroup.minLen = minLen;
                hufGroup.maxLen = maxLen;
                var base = hufGroup.base.subarray(1);
                var limit = hufGroup.limit.subarray(1);
                var pp = 0;
                for (var i = minLen; i <= maxLen; i++)
                    for (var t = 0; t < symCount; t++)
                        if (length[t] == i) hufGroup.permute[pp++] = t;
                for (i = minLen; i <= maxLen; i++) temp[i